import 'package:flutter/material.dart';

import '../app_session.dart';
import '../widgets/app_scaffold.dart';
import '../widgets/spread_view.dart';
import '../life_state.dart';

class DrawScreen extends StatefulWidget {
  const DrawScreen({
    super.key,
    required this.fortuneTypeKey,
    required this.title,
    this.initialQuestion,
    this.initialContext,
    this.initialUnit,
    this.showAiInterpretation = true,
    this.allowManualAi = true,
    this.useDetailedQuestionForm = false,
  });

  final String fortuneTypeKey;
  final String title;
  final String? initialQuestion;
  final String? initialContext;
  final String? initialUnit;
  final bool showAiInterpretation;
  final bool allowManualAi;
  final bool useDetailedQuestionForm;

  @override
  State<DrawScreen> createState() => _DrawScreenState();
}

class _DrawScreenState extends State<DrawScreen> {
  bool _loading = false;
  bool _revealed = false;
  String? _error;
  String? _readingId;
  dynamic _resultJson;
  String? _interpretationText;
  bool _loadingInterpretation = false;
  String? _interpretationError;
  bool _inputSent = false;
  bool _autoGenerated = false;
  final TextEditingController _questionController = TextEditingController();
  final TextEditingController _noteController = TextEditingController();
  String? _submittedQuestion;
  String? _submittedContext;
  String? _submittedUnit;

  bool get _questionFormAllowed =>
      !widget.fortuneTypeKey.startsWith('today_deep_') &&
      widget.fortuneTypeKey != 'today_free' &&
      widget.fortuneTypeKey != 'week_one' &&
      widget.fortuneTypeKey != 'compatibility';

  bool get _useDetailedForm => widget.useDetailedQuestionForm && _questionFormAllowed;
  bool get _useSimpleForm => !widget.useDetailedQuestionForm && _questionFormAllowed;

  @override
  void initState() {
    super.initState();
    _questionController.text = widget.initialQuestion ?? '';
    _noteController.text = widget.initialContext ?? '';
  }

  @override
  void dispose() {
    _questionController.dispose();
    _noteController.dispose();
    super.dispose();
  }

  Future<void> _draw() async {
    if (_loading || _revealed) return;
    setState(() {
      _loading = true;
      _error = null;
    });
    try {
      final input = _buildInputJsonPayload();
      final response = await AppSession.instance.api.postJson('/readings/execute', {
        'fortune_type_key': widget.fortuneTypeKey,
        if (input != null) 'input_json': input,
      });
      _readingId = response['reading_id'] as String;
      _resultJson = response['result_json'];
      await _refreshLifeSafe();
      if (!mounted) return;
      setState(() => _revealed = true);
      if (widget.showAiInterpretation && _readingId != null) {
        await _prepareInterpretation();
      }
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = e.toString());
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final showQuestionForm = _useDetailedForm || _useSimpleForm;
    return AppScaffold(
      title: 'カードを引く',
      subtitle: showQuestionForm ? '質問事項を入力してから、カードを引いてください。' : '',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(widget.title, style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          Text(
            _revealed
                ? (widget.showAiInterpretation
                    ? 'カードが出ました。結果を読み取っています...'
                    : 'カードが出ました。')
                : (showQuestionForm ? '質問事項を入力してから、ボタンを押してください。' : 'カードを引いてください。'),
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          if (showQuestionForm) ...[
            const SizedBox(height: 16),
            _questionField(),
          ],
          const SizedBox(height: 16),
          if (_error != null) ...[
            Text(_error!, style: const TextStyle(color: Colors.red)),
            const SizedBox(height: 12),
          ],
          if (_revealed) ...[
            _cardsView(),
            const SizedBox(height: 16),
            if (widget.showAiInterpretation) ...[
              _interpretationSection(),
              const SizedBox(height: 12),
            ],
            if (_loading && widget.showAiInterpretation)
              const Center(
                child: SizedBox(
                  width: 22,
                  height: 22,
                  child: CircularProgressIndicator(strokeWidth: 2),
                ),
              ),
          ] else
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _loading ? null : _draw,
                icon: _loading
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Icon(Icons.style),
                label: Text(_loading ? 'カードを引いています...' : 'カードを引く'),
              ),
            ),
        ],
      ),
    );
  }

  Widget _cardsView() {
    return SpreadView(resultJson: _resultJson);
  }

  Widget _interpretationSection() {
    if (_loadingInterpretation) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_interpretationError != null) {
      return Text(_interpretationError!, style: const TextStyle(color: Colors.red));
    }
    final output = _interpretationText ?? '';
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFFFCFAF6),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('AI解釈', style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),
          Text(output.isEmpty ? '解釈を生成中です...' : output),
        ],
      ),
    );
  }

  Future<void> _prepareInterpretation() async {
    if (_readingId == null) return;
    setState(() {
      _loadingInterpretation = true;
      _interpretationError = null;
    });
    try {
      await _sendInterpretationInput();
      await _loadInterpretation();
      await _autoGenerateIfNeeded();
    } catch (e) {
      _interpretationError = e.toString();
    } finally {
      if (mounted) {
        setState(() => _loadingInterpretation = false);
      }
    }
  }

  Future<void> _sendInterpretationInput() async {
    if (_inputSent || _resultJson == null || _resultJson is! Map) return;
    _inputSent = true;
    final payload = _buildInterpretationInput(_resultJson as Map);
    await AppSession.instance.api.postJson('/interpretations/input', {
      'reading_id': _readingId,
      'input_json': payload,
    });
  }

  Future<void> _loadInterpretation() async {
    if (_readingId == null) return;
    try {
      final response = await AppSession.instance.api.getJson('/interpretations/${_readingId!}');
      if (!mounted) return;
      setState(() {
        _interpretationText = response['output_text']?.toString();
      });
    } catch (_) {}
  }

  Future<void> _autoGenerateIfNeeded() async {
    if (_autoGenerated) return;
    final output = _interpretationText;
    if (output != null && output.trim().isNotEmpty) return;
    _autoGenerated = true;
    try {
      final response = await AppSession.instance.api.postJson(
        '/interpretations/generate?reading_id=${_readingId!}',
        {},
      );
      if (!mounted) return;
      setState(() {
        _interpretationText = response['output_text']?.toString();
      });
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _interpretationError = 'AI解釈の生成に失敗しました: $e';
      });
    }
  }

  Map<String, dynamic> _buildInterpretationInput(Map result) {
    final slots = result['slots'] as List<dynamic>? ?? [];
    final fortuneTypeKey = result['fortune_type_key'];
    final type = result['type']?.toString() ?? '';
    final cards = <Map<String, dynamic>>[];

    for (var i = 0; i < slots.length; i++) {
      final slot = slots[i];
      if (slot is! Map) continue;
      final card = slot['card'] ?? {};
      cards.add({
        'position': _mapPositionLabel(type, i, slot['position']?.toString() ?? ''),
        'card_name': card['name'],
        'arcana': card['arcana'],
        'suit': card['suit'],
        'rank': card['rank'],
        'upright': card['upright'],
        'meaning_short': null,
        'keywords': [],
      });
    }

    final baseCard = result['base_card'];
    if (baseCard != null) {
      cards.insert(0, {
        'position': type == 'today_deep' ? '総合' : 'base',
        'card_name': baseCard['name'],
        'arcana': baseCard['arcana'],
        'suit': baseCard['suit'],
        'rank': baseCard['rank'],
        'upright': baseCard['upright'],
        'meaning_short': null,
        'keywords': [],
      });
    }

    final extraCards = result['extra_cards'] as List<dynamic>?;
    if (extraCards != null) {
      for (final card in extraCards) {
        cards.add({
          'position': 'extra',
          'card_name': card['name'],
          'arcana': card['arcana'],
          'suit': card['suit'],
          'rank': card['rank'],
          'upright': card['upright'],
          'meaning_short': null,
          'keywords': [],
        });
      }
    }

    return {
      'type': result['type'],
      'fortune_type_key': fortuneTypeKey,
      'question': (_submittedQuestion ?? widget.initialQuestion ?? '').trim(),
      'context': (_submittedContext ?? widget.initialContext ?? '').trim(),
      if ((_submittedUnit ?? widget.initialUnit)?.isNotEmpty ?? false) 'unit': (_submittedUnit ?? widget.initialUnit),
      'cards': cards,
    };
  }

  String _mapPositionLabel(String type, int index, String fallback) {
    if (type == 'hexagram') {
      const labels = ['過去', '立場', '現在', '未来', 'アドバイス', '周囲', '結果'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    if (type == 'celtic_cross') {
      const labels = ['現状', 'キー', '表層', '深層', '過去', '未来', '総合', '希望と恐れ', '周囲', '立場'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    if (type == 'triangle_warning') {
      const labels = ['動機', '機会', '自己正当化'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    if (type == 'compatibility') {
      const labels = ['相手', '相性', '自分'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    if (type == 'today_deep') {
      const labels = ['恋愛', '仕事', '金運', 'トラブル'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    return fallback;
  }

  Widget _questionField() {
    if (_useDetailedForm) {
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: const Color(0xFFFCFAF6),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('質問事項', style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            TextField(
              controller: _questionController,
              readOnly: _revealed,
              decoration: const InputDecoration(labelText: '質問（任意）'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: _noteController,
              readOnly: _revealed,
              maxLines: 2,
              decoration: const InputDecoration(labelText: '補足（任意）'),
            ),
            const SizedBox(height: 12),
            SizedBox(
              width: double.infinity,
              child: OutlinedButton(
                onPressed: _revealed ? null : _saveDetailedInput,
                child: const Text('質問事項を保存'),
              ),
            ),
          ],
        ),
      );
    }
    return TextField(
      controller: _questionController,
      readOnly: _revealed,
      maxLines: 2,
      decoration: const InputDecoration(
        labelText: '質問事項',
        hintText: '占ってほしい内容を入力してください',
        border: OutlineInputBorder(),
      ),
    );
  }

  void _saveDetailedInput() {
    final question = _questionController.text.trim();
    final note = _noteController.text.trim();
    setState(() {
      _submittedQuestion = question.isNotEmpty ? question : null;
      _submittedContext = note.isNotEmpty ? note : null;
    });
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('質問事項を保存しました')),
    );
  }

  Future<void> _refreshLifeSafe() async {
    try {
      await LifeState.instance.refresh();
    } catch (_) {}
  }

  Map<String, dynamic>? _buildInputJsonPayload() {
    final payload = <String, dynamic>{};
    String? questionValue;
    String? contextValue;

    if (_useDetailedForm || _useSimpleForm) {
      final value = _questionController.text.trim();
      if (value.isNotEmpty) {
        payload['question'] = value;
        questionValue = value;
      }
    } else if ((widget.initialQuestion?.trim().isNotEmpty ?? false)) {
      final value = widget.initialQuestion!.trim();
      payload['question'] = value;
      questionValue = value;
    }

    if (_useDetailedForm) {
      final note = _noteController.text.trim();
      if (note.isNotEmpty) {
        payload['context'] = note;
        contextValue = note;
      }
    } else {
      final note = widget.initialContext?.trim();
      if (note != null && note.isNotEmpty) {
        payload['context'] = note;
        contextValue = note;
      }
    }

    final unitValue = widget.initialUnit?.trim();
    if (unitValue != null && unitValue.isNotEmpty) {
      payload['unit'] = unitValue;
    }

    final submittedQuestion = questionValue ?? _questionController.text.trim();
    _submittedQuestion = submittedQuestion.isNotEmpty ? submittedQuestion : null;
    _submittedContext = contextValue;
    _submittedUnit = unitValue;

    return payload.isEmpty ? null : payload;
  }
}
