import 'package:flutter/material.dart';

import '../app_session.dart';
import '../widgets/app_scaffold.dart';
import '../widgets/spread_view.dart';

class DrawScreen extends StatefulWidget {
  const DrawScreen({
    super.key,
    required this.fortuneTypeKey,
    required this.title,
    this.initialQuestion,
    this.initialContext,
    this.initialUnit,
    this.showAiInterpretation = true,
    this.allowManualAi = true,
  });

  final String fortuneTypeKey;
  final String title;
  final String? initialQuestion;
  final String? initialContext;
  final String? initialUnit;
  final bool showAiInterpretation;
  final bool allowManualAi;

  @override
  State<DrawScreen> createState() => _DrawScreenState();
}

class _DrawScreenState extends State<DrawScreen> {
  bool _loading = false;
  bool _revealed = false;
  String? _error;
  String? _readingId;
  dynamic _resultJson;
  String? _interpretationText;
  bool _loadingInterpretation = false;
  String? _interpretationError;
  bool _inputSent = false;
  bool _autoGenerated = false;

  Future<void> _draw() async {
    if (_loading || _revealed) return;
    setState(() {
      _loading = true;
      _error = null;
    });
    try {
      final response = await AppSession.instance.api.postJson('/readings/execute', {
        'fortune_type_key': widget.fortuneTypeKey,
      });
      _readingId = response['reading_id'] as String;
      _resultJson = response['result_json'];
      if (!mounted) return;
      setState(() => _revealed = true);
      if (widget.showAiInterpretation && _readingId != null) {
        await _prepareInterpretation();
      }
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = e.toString());
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final showQuestionCopy = !widget.fortuneTypeKey.startsWith('today_deep_') &&
        widget.fortuneTypeKey != 'today_free' &&
        widget.fortuneTypeKey != 'week_one';
    return AppScaffold(
      title: 'カードを引く',
      subtitle: showQuestionCopy ? '質問事項を入力してから、カードを引いてください。' : '',
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(widget.title, style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          Text(
            _revealed
                ? (widget.showAiInterpretation
                    ? 'カードが出ました。結果を読み取っています...'
                    : 'カードが出ました。')
                : (showQuestionCopy ? '質問事項を入力してから、ボタンを押してください。' : 'カードを引いてください。'),
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          const SizedBox(height: 16),
          if (_error != null) ...[
            Text(_error!, style: const TextStyle(color: Colors.red)),
            const SizedBox(height: 12),
          ],
          if (_revealed) ...[
            _cardsView(),
            const SizedBox(height: 16),
            if (widget.showAiInterpretation) ...[
              _interpretationSection(),
              const SizedBox(height: 12),
            ],
            if (_loading && widget.showAiInterpretation)
              const Center(
                child: SizedBox(
                  width: 22,
                  height: 22,
                  child: CircularProgressIndicator(strokeWidth: 2),
                ),
              ),
          ] else
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _loading ? null : _draw,
                icon: _loading
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Icon(Icons.style),
                label: Text(_loading ? 'カードを引いています...' : 'カードを引く'),
              ),
            ),
        ],
      ),
    );
  }

  Widget _cardsView() {
    return SpreadView(resultJson: _resultJson);
  }

  Widget _interpretationSection() {
    if (_loadingInterpretation) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_interpretationError != null) {
      return Text(_interpretationError!, style: const TextStyle(color: Colors.red));
    }
    final output = _interpretationText ?? '';
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFFFCFAF6),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('AI解釈', style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),
          Text(output.isEmpty ? '解釈を生成中です...' : output),
        ],
      ),
    );
  }

  Future<void> _prepareInterpretation() async {
    if (_readingId == null) return;
    setState(() {
      _loadingInterpretation = true;
      _interpretationError = null;
    });
    try {
      await _sendInterpretationInput();
      await _loadInterpretation();
      await _autoGenerateIfNeeded();
    } catch (e) {
      _interpretationError = e.toString();
    } finally {
      if (mounted) {
        setState(() => _loadingInterpretation = false);
      }
    }
  }

  Future<void> _sendInterpretationInput() async {
    if (_inputSent || _resultJson == null || _resultJson is! Map) return;
    _inputSent = true;
    final payload = _buildInterpretationInput(_resultJson as Map);
    await AppSession.instance.api.postJson('/interpretations/input', {
      'reading_id': _readingId,
      'input_json': payload,
    });
  }

  Future<void> _loadInterpretation() async {
    if (_readingId == null) return;
    try {
      final response = await AppSession.instance.api.getJson('/interpretations/${_readingId!}');
      if (!mounted) return;
      setState(() {
        _interpretationText = response['output_text']?.toString();
      });
    } catch (_) {}
  }

  Future<void> _autoGenerateIfNeeded() async {
    if (_autoGenerated) return;
    final output = _interpretationText;
    if (output != null && output.trim().isNotEmpty) return;
    _autoGenerated = true;
    try {
      final response = await AppSession.instance.api.postJson(
        '/interpretations/generate?reading_id=${_readingId!}',
        {},
      );
      if (!mounted) return;
      setState(() {
        _interpretationText = response['output_text']?.toString();
      });
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _interpretationError = 'AI解釈の生成に失敗しました: $e';
      });
    }
  }

  Map<String, dynamic> _buildInterpretationInput(Map result) {
    final slots = result['slots'] as List<dynamic>? ?? [];
    final fortuneTypeKey = result['fortune_type_key'];
    final type = result['type']?.toString() ?? '';
    final cards = <Map<String, dynamic>>[];

    for (var i = 0; i < slots.length; i++) {
      final slot = slots[i];
      if (slot is! Map) continue;
      final card = slot['card'] ?? {};
      cards.add({
        'position': _mapPositionLabel(type, i, slot['position']?.toString() ?? ''),
        'card_name': card['name'],
        'arcana': card['arcana'],
        'suit': card['suit'],
        'rank': card['rank'],
        'upright': card['upright'],
        'meaning_short': null,
        'keywords': [],
      });
    }

    final baseCard = result['base_card'];
    if (baseCard != null) {
      cards.insert(0, {
        'position': type == 'today_deep' ? '総合' : 'base',
        'card_name': baseCard['name'],
        'arcana': baseCard['arcana'],
        'suit': baseCard['suit'],
        'rank': baseCard['rank'],
        'upright': baseCard['upright'],
        'meaning_short': null,
        'keywords': [],
      });
    }

    final extraCards = result['extra_cards'] as List<dynamic>?;
    if (extraCards != null) {
      for (final card in extraCards) {
        cards.add({
          'position': 'extra',
          'card_name': card['name'],
          'arcana': card['arcana'],
          'suit': card['suit'],
          'rank': card['rank'],
          'upright': card['upright'],
          'meaning_short': null,
          'keywords': [],
        });
      }
    }

    return {
      'type': result['type'],
      'fortune_type_key': fortuneTypeKey,
      'question': widget.initialQuestion?.trim() ?? '',
      'context': widget.initialContext?.trim() ?? '',
      if (widget.initialUnit != null) 'unit': widget.initialUnit,
      'cards': cards,
    };
  }

  String _mapPositionLabel(String type, int index, String fallback) {
    if (type == 'hexagram') {
      const labels = ['過去', '立場', '現在', '未来', 'アドバイス', '周囲', '結果'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    if (type == 'celtic_cross') {
      const labels = ['現状', 'キー', '表層', '過去', '未来', '深層', '総合', '希望と恐れ', '周囲', '立場'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    if (type == 'triangle_warning') {
      const labels = ['動機', '機会', '自己正当化'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    if (type == 'compatibility') {
      const labels = ['相手', '相性', '自分'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    if (type == 'today_deep') {
      const labels = ['恋愛', '仕事', '金運', 'トラブル'];
      if (index >= 0 && index < labels.length) return labels[index];
    }
    return fallback;
  }
}
