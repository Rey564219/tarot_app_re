import 'package:flutter/material.dart';

import '../app_session.dart';
import '../widgets/spread_view.dart';

class ReadingScreen extends StatefulWidget {
  const ReadingScreen({
    super.key,
    required this.readingId,
    this.resultJson,
    this.initialQuestion,
    this.initialContext,
    this.allowManualAi = true,
  });

  final String readingId;
  final dynamic resultJson;
  final String? initialQuestion;
  final String? initialContext;
  final bool allowManualAi;

  @override
  State<ReadingScreen> createState() => _ReadingScreenState();
}

class _ReadingScreenState extends State<ReadingScreen> {
  bool _loading = false;
  dynamic _result;
  String? _error;
  bool _inputSent = false;
  Map<String, dynamic>? _interpretation;
  List<dynamic> _history = [];
  final _questionController = TextEditingController();
  final _contextController = TextEditingController();
  bool _savingInput = false;
  bool _generating = false;
  bool _autoGenerated = false;

  @override
  void initState() {
    super.initState();
    _result = widget.resultJson;
    if (widget.initialQuestion != null && widget.initialQuestion!.isNotEmpty) {
      _questionController.text = widget.initialQuestion!;
    }
    if (widget.initialContext != null && widget.initialContext!.isNotEmpty) {
      _contextController.text = widget.initialContext!;
    }
    if (_result == null) {
      _fetch();
    } else {
      _sendInterpretationInput().then((_) async {
        await _loadInterpretation();
        await _loadHistory();
        await _autoGenerateIfNeeded();
      });
    }
  }

  Future<void> _fetch() async {
    setState(() => _loading = true);
    try {
      final response = await AppSession.instance.api.getJson('/readings/${widget.readingId}');
      setState(() => _result = response['result_json']);
      await _sendInterpretationInput();
      await _loadInterpretation();
      await _loadHistory();
      await _autoGenerateIfNeeded();
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('占い結果')),
      body: Padding(
        padding: const EdgeInsets.all(20),
        child: _loading
            ? const Center(child: CircularProgressIndicator())
            : _error != null
                ? Text(_error!, style: const TextStyle(color: Colors.red))
                : _result == null
                    ? const Text('結果がありません')
                    : _buildResultView(_result),
      ),
    );
  }

  Widget _buildResultView(dynamic result) {
    if (result is! Map) {
      return ListView(
        children: [
          Text('結果', style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          Text(AppSession.prettyJson(result)),
        ],
      );
    }

    final title = result['type']?.toString() ?? 'reading';
    final slots = result['slots'] as List<dynamic>? ?? [];
    final baseCard = result['base_card'];
    final extraCards = result['extra_cards'] as List<dynamic>?;

    return ListView(
      children: [
        Text(title, style: Theme.of(context).textTheme.titleLarge),
        const SizedBox(height: 12),
        if (_showQuestionSection(result)) ...[
          _questionSection(),
          const SizedBox(height: 12),
        ],
        SpreadView(resultJson: result),
        const SizedBox(height: 16),
        if (baseCard != null)
          Card(
            child: ListTile(
              title: Text(baseCard['name'] ?? ''),
              subtitle: Text(_formatCard(baseCard)),
            ),
          ),
        ...slots.map((slot) {
          final card = slot['card'];
          return Card(
            child: ListTile(
              title: Text('${slot['position']}'),
              subtitle: Text('${card['name']} • ${_formatCard(card)}'),
            ),
          );
        }).toList(),
        if (extraCards != null && extraCards.isNotEmpty) ...[
          const SizedBox(height: 12),
          Text('追加カード', style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),
          ...extraCards.map((card) {
            return Card(
              child: ListTile(
                title: Text(card['name']),
                subtitle: Text(_formatCard(card)),
              ),
            );
          }).toList(),
        ],
        const SizedBox(height: 16),
        _aiPlaceholder(),
        const SizedBox(height: 12),
        if (widget.allowManualAi) _historySection(),
      ],
    );
  }

  String _formatCard(dynamic card) {
    if (card is! Map) return '';
    final suit = card['suit'];
    final rank = card['rank'];
    final arcana = card['arcana'] ?? '';
    final upright = card['upright'];
    final position = upright == null ? '正逆なし' : (upright == true ? '正位置' : '逆位置');
    final detail = suit != null ? '$rank of $suit' : arcana;
    return '$detail / $position';
  }

  Widget _aiPlaceholder() {
    final output = _interpretation?['output_text'];
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFFFCFAF6),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('AI解釈', style: TextStyle(fontWeight: FontWeight.bold)),
          const SizedBox(height: 8),
          Text(output == null || output.toString().isEmpty ? '（未生成）' : output.toString()),
        ],
      ),
    );
  }

  Widget _historySection() {
    if (_history.isEmpty) {
      return const SizedBox.shrink();
    }
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('生成履歴', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: 8),
        ..._history.map((item) {
          return Card(
            child: ListTile(
              title: Text('v${item['version']} • ${item['model'] ?? ''}'),
              subtitle: Text(item['output_text'] ?? ''),
            ),
          );
        }).toList(),
      ],
    );
  }

  Future<void> _sendInterpretationInput() async {
    if (_inputSent || _result == null || _result is! Map) return;
    _inputSent = true;
    try {
      final payload = _buildInterpretationInput(_result as Map);
      await AppSession.instance.api.postJson('/interpretations/input', {
        'reading_id': widget.readingId,
        'input_json': payload,
      });
    } catch (_) {}
  }

  Future<void> _loadInterpretation() async {
    try {
      final response = await AppSession.instance.api.getJson('/interpretations/${widget.readingId}');
      if (!mounted) return;
      setState(() {
        _interpretation = response;
        final input = response['input_json'];
        if (input is Map) {
          _questionController.text = input['question']?.toString() ?? '';
          _contextController.text = input['context']?.toString() ?? '';
        }
      });
    } catch (_) {}
  }

  Future<void> _loadHistory() async {
    try {
      final response = await AppSession.instance.api.getJson('/interpretations/${widget.readingId}/history');
      if (!mounted) return;
      setState(() => _history = response['items'] as List<dynamic>);
    } catch (_) {}
  }

  Future<void> _generateInterpretation() async {
    setState(() => _generating = true);
    try {
      final response = await _generateWithRetry();
      if (!mounted) return;
      setState(() {
        _interpretation = {
          'output_text': response['output_text'],
          'input_json': response['input_json'],
        };
      });
      await _loadHistory();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('生成エラー: $e')),
      );
    } finally {
      if (mounted) setState(() => _generating = false);
    }
  }

  Future<void> _autoGenerateIfNeeded() async {
    if (_autoGenerated || _generating) return;
    final output = _interpretation?['output_text'];
    if (output != null && output.toString().trim().isNotEmpty) return;
    _autoGenerated = true;
    try {
      final response = await _generateWithRetry();
      if (!mounted) return;
      setState(() {
        _interpretation = {
          'output_text': response['output_text'],
          'input_json': response['input_json'],
        };
      });
      await _loadHistory();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('AI解釈の自動生成に失敗しました: $e')),
      );
    }
  }

  Map<String, dynamic> _buildInterpretationInput(Map result) {
    final showQuestion = _showQuestionSection(result);
    final slots = result['slots'] as List<dynamic>? ?? [];
    final fortuneTypeKey = result['fortune_type_key'];
    final cards = slots.map((slot) {
      final card = slot['card'] ?? {};
      return {
        'position': slot['position'],
        'card_name': card['name'],
        'arcana': card['arcana'],
        'suit': card['suit'],
        'rank': card['rank'],
        'upright': card['upright'],
        'meaning_short': null,
        'keywords': [],
      };
    }).toList();

    final baseCard = result['base_card'];
    if (baseCard != null) {
      cards.insert(0, {
        'position': 'base',
        'card_name': baseCard['name'],
        'arcana': baseCard['arcana'],
        'suit': baseCard['suit'],
        'rank': baseCard['rank'],
        'upright': baseCard['upright'],
        'meaning_short': null,
        'keywords': [],
      });
    }

    final extraCards = result['extra_cards'] as List<dynamic>?;
    if (extraCards != null) {
      for (final card in extraCards) {
        cards.add({
          'position': 'extra',
          'card_name': card['name'],
          'arcana': card['arcana'],
          'suit': card['suit'],
          'rank': card['rank'],
          'upright': card['upright'],
          'meaning_short': null,
          'keywords': [],
        });
      }
    }

    return {
      'type': result['type'],
      'fortune_type_key': fortuneTypeKey,
      'question': showQuestion ? _questionController.text.trim() : '',
      'context': showQuestion ? _contextController.text.trim() : '',
      'cards': cards,
    };
  }

  bool _showQuestionSection(Map result) {
    final type = result['type']?.toString() ?? '';
    const hiddenTypes = {
      'today_free',
      'today_deep_love',
      'today_deep_work',
      'today_deep_money',
      'today_deep_trouble',
      'compatibility',
    };
    return !hiddenTypes.contains(type);
  }

  Widget _questionSection() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFFFCFAF6),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('質問事項', style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 8),
          TextField(
            controller: _questionController,
            decoration: const InputDecoration(labelText: '質問（任意）'),
          ),
          const SizedBox(height: 8),
          TextField(
            controller: _contextController,
            decoration: const InputDecoration(labelText: '補足（任意）'),
            maxLines: 2,
          ),
          const SizedBox(height: 8),
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              onPressed: _savingInput ? null : _saveInput,
              child: _savingInput
                  ? const SizedBox(
                      width: 18,
                      height: 18,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('質問事項を保存'),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _saveInput() async {
    if (_result == null || _result is! Map) return;
    setState(() => _savingInput = true);
    try {
      final payload = _buildInterpretationInput(_result as Map);
      await AppSession.instance.api.postJson('/interpretations/input', {
        'reading_id': widget.readingId,
        'input_json': payload,
      });
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('質問事項を保存しました')),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('保存エラー: $e')),
      );
    } finally {
      if (mounted) setState(() => _savingInput = false);
    }
  }

  Future<Map<String, dynamic>> _generateWithRetry() async {
    const attempts = 3;
    var lastError = '';
    for (var attempt = 1; attempt <= attempts; attempt++) {
      try {
        return await AppSession.instance.api.postJson(
          '/interpretations/generate?reading_id=${widget.readingId}',
          {},
        );
      } catch (e) {
        lastError = e.toString();
        if (attempt == attempts) break;
        await Future.delayed(Duration(milliseconds: 800 * attempt));
      }
    }
    throw Exception(lastError);
  }
}
