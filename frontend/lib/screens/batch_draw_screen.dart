import 'package:flutter/material.dart';

import '../app_session.dart';
import '../widgets/app_scaffold.dart';
import '../widgets/spread_view.dart';

class BatchDrawScreen extends StatefulWidget {
  const BatchDrawScreen({
    super.key,
    required this.title,
    required this.fortuneTypeKeys,
    required this.labels,
  });

  final String title;
  final List<String> fortuneTypeKeys;
  final Map<String, String> labels;

  @override
  State<BatchDrawScreen> createState() => _BatchDrawScreenState();
}

class _BatchDrawScreenState extends State<BatchDrawScreen> {
  bool _loading = true;
  String? _error;
  List<dynamic> _items = [];

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    setState(() {
      _loading = true;
      _error = null;
    });
    try {
      final response = await AppSession.instance.api.postJson('/readings/execute-batch', {
        'fortune_type_keys': widget.fortuneTypeKeys,
      });
      if (!mounted) return;
      setState(() {
        _items = response['items'] as List<dynamic>;
      });
    } catch (e) {
      if (!mounted) return;
      setState(() => _error = e.toString());
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return AppScaffold(
      title: widget.title,
      subtitle: 'カードの結果とAI解釈をまとめて表示します。',
      actions: [
        IconButton(icon: const Icon(Icons.refresh), onPressed: _load),
      ],
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (_loading) const Center(child: CircularProgressIndicator()),
          if (_error != null) Text(_error!, style: const TextStyle(color: Colors.red)),
          ..._items.map((item) {
            final key = item['fortune_type_key']?.toString() ?? '';
            final title = widget.labels[key] ?? key;
            return Padding(
              padding: const EdgeInsets.only(bottom: 20),
              child: BatchReadingCard(
                title: title,
                readingId: item['reading_id'],
                resultJson: item['result_json'],
              ),
            );
          }).toList(),
        ],
      ),
    );
  }
}

class BatchReadingCard extends StatefulWidget {
  const BatchReadingCard({
    super.key,
    required this.title,
    required this.readingId,
    required this.resultJson,
  });

  final String title;
  final String readingId;
  final dynamic resultJson;

  @override
  State<BatchReadingCard> createState() => _BatchReadingCardState();
}

class _BatchReadingCardState extends State<BatchReadingCard> {
  String? _interpretationText;
  bool _loading = true;
  String? _error;
  bool _inputSent = false;
  bool _autoGenerated = false;

  @override
  void initState() {
    super.initState();
    _prepare();
  }

  Future<void> _prepare() async {
    setState(() {
      _loading = true;
      _error = null;
    });
    try {
      await _sendInterpretationInput();
      await _loadInterpretation();
      await _autoGenerateIfNeeded();
    } catch (e) {
      _error = e.toString();
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  Future<void> _sendInterpretationInput() async {
    if (_inputSent || widget.resultJson == null || widget.resultJson is! Map) return;
    _inputSent = true;
    final payload = _buildInterpretationInput(widget.resultJson as Map);
    await AppSession.instance.api.postJson('/interpretations/input', {
      'reading_id': widget.readingId,
      'input_json': payload,
    });
  }

  Future<void> _loadInterpretation() async {
    try {
      final response = await AppSession.instance.api.getJson('/interpretations/${widget.readingId}');
      if (!mounted) return;
      setState(() {
        _interpretationText = response['output_text']?.toString();
      });
    } catch (_) {}
  }

  Future<void> _autoGenerateIfNeeded() async {
    if (_autoGenerated) return;
    final output = _interpretationText;
    if (output != null && output.trim().isNotEmpty) return;
    _autoGenerated = true;
    try {
      final response = await AppSession.instance.api.postJson(
        '/interpretations/generate?reading_id=${widget.readingId}',
        {},
      );
      if (!mounted) return;
      setState(() {
        _interpretationText = response['output_text']?.toString();
      });
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _error = 'AI解釈の生成に失敗しました: $e';
      });
    }
  }

  Map<String, dynamic> _buildInterpretationInput(Map result) {
    final slots = result['slots'] as List<dynamic>? ?? [];
    final fortuneTypeKey = result['fortune_type_key'];
    final cards = slots.map((slot) {
      final card = slot['card'] ?? {};
      return {
        'position': slot['position'],
        'card_name': card['name'],
        'arcana': card['arcana'],
        'suit': card['suit'],
        'rank': card['rank'],
        'upright': card['upright'],
        'meaning_short': null,
        'keywords': [],
      };
    }).toList();

    final baseCard = result['base_card'];
    if (baseCard != null) {
      cards.insert(0, {
        'position': 'base',
        'card_name': baseCard['name'],
        'arcana': baseCard['arcana'],
        'suit': baseCard['suit'],
        'rank': baseCard['rank'],
        'upright': baseCard['upright'],
        'meaning_short': null,
        'keywords': [],
      });
    }

    final extraCards = result['extra_cards'] as List<dynamic>?;
    if (extraCards != null) {
      for (final card in extraCards) {
        cards.add({
          'position': 'extra',
          'card_name': card['name'],
          'arcana': card['arcana'],
          'suit': card['suit'],
          'rank': card['rank'],
          'upright': card['upright'],
          'meaning_short': null,
          'keywords': [],
        });
      }
    }

    return {
      'type': result['type'],
      'fortune_type_key': fortuneTypeKey,
      'question': '',
      'context': '',
      'cards': cards,
    };
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: const Color(0xFFFCFAF6),
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(widget.title, style: Theme.of(context).textTheme.titleMedium),
          const SizedBox(height: 12),
          SpreadView(resultJson: widget.resultJson),
          const SizedBox(height: 16),
          if (_loading)
            const Center(child: CircularProgressIndicator())
          else if (_error != null)
            Text(_error!, style: const TextStyle(color: Colors.red))
          else
            _interpretationBox(context),
        ],
      ),
    );
  }

  Widget _interpretationBox(BuildContext context) {
    final output = _interpretationText ?? '';
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('AI解釈', style: Theme.of(context).textTheme.titleSmall),
          const SizedBox(height: 6),
          Text(output.isEmpty ? '解釈を生成中です…' : output),
        ],
      ),
    );
  }
}
